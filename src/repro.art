
fn @div_up(a: i32, b: i32) -> i32 {
	(a + b - 1) / b
}

fn @min(a: i32, b: i32) -> i32 { if a < b { a } else { b } }

static warp_size = 8;
static num_blocks_in_flight = 32;

fn @cpu_atomic_load[T](location: &addrspace(1) T)
	= atomic_load[T](bitcast[&T](location), 7, "");

fn @cpu_atomic_store[T](location: &mut addrspace(1) T, value: T)
	= atomic_store[T](bitcast[&mut T](location), value, 7, "");


fn @cpu_launch_1d(body: fn(i32) -> ()) -> fn(i32, i32) -> () {

	@|num_blocks: i32, num_threads_per_block: i32| -> () {

		let num_warps_per_block = (num_threads_per_block + warp_size - 1) / warp_size;
		let num_warps = num_blocks * num_warps_per_block;
		let num_threads = num_blocks * num_threads_per_block;
		let num_blocks_in_flight = min(num_blocks, num_blocks_in_flight);

		fn @warp_loop(body: fn(i32)->()) = @|l:i32| vectorize(l, body);
		//fn @warp_loop(body: fn(i32)->()) = @|l:i32| range(body)(0, l);

		for block_id in range(0, num_blocks_in_flight) {
			for warp_id in range(0, num_warps_per_block) {
				for logical_block_id in range_step(block_id, num_blocks, num_blocks_in_flight) {

					for local_id in warp_loop(warp_size) {
						@body(logical_block_id * num_threads_per_block + warp_id * warp_size + local_id)
					}
				}
			}
		}
	}
}

fn print_2xi32(i: i32, j: i32) -> () {
	for l in unroll(0, warp_size) {
		if l == rv_lane_id() {
			print_string("pushed_buffer(");
			print_i32(i);
			print_string(") = ");
			print_i32(j);
			print_char('\n');
			print_flush();
		}
	}
}

#[export]
fn main() -> i32 {

	let pushed_buffer_size = 1024;
	let padding = 5;

	let block_dim = 16;
	let num_groups = div_up(pushed_buffer_size + padding, block_dim);
	
	let device_buffer = alloc_cpu((pushed_buffer_size as i64 + 5) * sizeof[u32]());
	let device_memory = device_buffer.data;

	let pushed_buffer = bitcast[&mut addrspace(1) [i32]](device_memory);

	fn pushed_buffer_addr(idx: i32) -> &mut addrspace(1) i32 { &mut pushed_buffer(idx) };
	fn set_pushed_buffer(idx: i32, value: i32) -> () {
		print_2xi32(idx, value);
		cpu_atomic_store[i32](pushed_buffer_addr(idx), value);
	}
	//fn get_pushed_buffer(idx: i32) -> i32 = cpu_atomic_load[i32](pushed_buffer_addr(idx));

	for tid in cpu_launch_1d(num_groups, block_dim) {

		if tid >= pushed_buffer_size {
			if tid < (pushed_buffer_size + 5) {
				set_pushed_buffer(tid, 0);
			}
		}
		else {
			set_pushed_buffer(tid, -2);
		}

		// TODO: this version of control flow works
		/*
		if tid < (pushed_buffer_size + 5) {
			if tid >= pushed_buffer_size {
				if tid < (pushed_buffer_size + 5) {
					set_pushed_buffer(tid, 0);
				}
			}
			else {
				set_pushed_buffer(tid, -2);
			}
		}
		*/

	}

	release(device_buffer);

	0
}
