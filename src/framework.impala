

extern "device" {
	fn "printf" cuda_device_print_i32(&[u8], i32) -> i32;
	fn "printf" cuda_device_print_i32_i32(&[u8], i32, i32) -> i32;
	fn "printf" cuda_device_print_i32_i32_i32(&[u8], i32, i32, i32) -> i32;
	fn "printf" cuda_device_print_i32_i32_i32_i32(&[u8], i32, i32, i32, i32) -> i32;
	fn "printf" cuda_device_print_i32_i32_i32_i32_i32(&[u8], i32, i32, i32, i32, i32) -> i32;
	fn "printf" cuda_device_print_i32_i32_i32_i32_i32_i32(&[u8], i32, i32, i32, i32, i32, i32) -> i32;
}


fn @div_up(a: i32, b: i32) -> i32 {
	(a + b - 1) / b
}

struct AccDevice {
	launch_1d: fn(i32, i32, fn (gpu_grid_context, gpu_intrinsics) -> ()) -> (),
	alloc: fn(i32) -> Buffer,
	platform_device: i32,
	print_i32: fn(&[u8], i32) -> ()
}

struct BaseTest {
	run_test: fn (fn (AccDevice, &mut[1][i8], &mut[1]u32) -> bool) -> (),
	finish: fn () -> i32
}

fn createBaseTest(additional_mem: i32) -> BaseTest {
	let device = createAccDevice();

	let memory_size = round_up(0 + sizeof[u32](), sizeof[u32]());
	let device_test_state_alloc = device.alloc(memory_size);
	let device_memory = bitcast[&mut[1][i8]](device_test_state_alloc.data);
	let device_failed_flag = bitcast[&mut[1]u32](&mut device_memory(memory_size - sizeof[u32]()));

	let zero: u32 = 0u32;
	runtime_copy(0, bitcast[&[i8]](&zero), 0i64, device.platform_device, bitcast[&mut[i8]](device_failed_flag), 0i64, sizeof[u32]() as i64);

	let mut cpu_result: bool = true;

	BaseTest {
		run_test: @|body| {
			cpu_result = cpu_result & body(device, device_memory, device_failed_flag);
		},

		finish: @|| {
			let mut gpu_result: u32;
			runtime_copy(device.platform_device, bitcast[&mut[i8]](device_failed_flag), 0i64, 0, bitcast[&mut[i8]](&mut gpu_result), 0i64, sizeof[u32]() as i64);

			release(device_test_state_alloc);

			(if cpu_result { 0 } else { 1 }) + gpu_result as i32
		}
	}
}


struct QueueTest {
	run_test: fn (i32, fn (AccDevice, ProducerConsumerQueue, &mut[1][i8], &mut[1]u32) -> bool) -> (),
	finish: fn () -> i32
}

fn createQueueTest(additional_mem: i32) -> QueueTest {
	let test = createBaseTest(additional_mem);

	// cuda_device is a static in cuda_mapping
	// device is a struct from createAccDevice()

	QueueTest {
		run_test: @|queue_size, body| {
			// let queue_buffer = alloc_cuda(device, queue_size * sizeof[i32]());
			// let queue_storage = bitcast[&mut[1][u32]](queue_buffer.data);

			with device, device_memory, device_failed_flag in test.run_test() {
				let queue = createProducerConsumerQueue(device, /*queue_storage,*/ queue_size);

				queue.reset();

				let mut cpu_result: bool = true;

				// TODO: properly refactor benchmark
				//with benchmark_cuda(cuda_device, 32) {
					if !body(device, queue, device_memory, device_failed_flag) {
						cpu_result = false;
					}
				//}

				queue.validate(device_failed_flag);
				queue.release();

				cpu_result
			}
		},

		finish: @|| {
			test.finish()
		}
	}
}
