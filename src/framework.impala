fn @get_member_mask_u32(size: u32) -> u32 {
	if size == 32u32 { -1u32 } else { (1u32 << size as u32) - 1u32 }
}

fn @get_member_mask_u64(size: u32) -> u64 {
	if size == 64u32 { -1u64 } else { (1u64 << size as u64) - 1u64 }
}

fn @div_up(a: i32, b: i32) -> i32 {
	(a + b - 1) / b
}

type index_wrapper = fn (fn (i32) -> u32) -> fn (i32) -> u32;
type dim_wrapper = fn (fn (i32) -> u32) -> fn (i32) -> u32;

fn @wrap_index_1d(idx: fn (i32) -> u32) -> fn (i32) -> u32 {
	@|i: i32| -> u32 {
		if ?i {
			match i { 0 => idx(0), _ => 0u32 }
		}
		else {
			idx(i)
		}
	}
}

fn @wrap_index_2d(idx: fn (i32) -> u32) -> fn (i32) -> u32 {
	@|i: i32| -> u32 {
		if ?i {
			match i { 0 => idx(0), 1 => idx(1), _ => 0u32 }
		}
		else {
			idx(i)
		}
	}
}

fn @wrap_index_3d(idx: fn (i32) -> u32) -> fn (i32) -> u32 {
	@|i: i32| -> u32 {
		if ?i {
			match i { 0 => idx(0), 1 => idx(1), 2 => idx(2), _ => 0u32 }
		}
		else {
			idx(i)
		}
	}
}

fn @wrap_dim_1d(idx: fn (i32) -> u32) -> fn (i32) -> u32 {
	@|i: i32| -> u32 {
		if ?i {
			match i { 0 => idx(0), _ => 1u32 }
		}
		else {
			idx(i)
		}
	}
}

fn @wrap_dim_2d(idx: fn (i32) -> u32) -> fn (i32) -> u32 {
	@|i: i32| -> u32 {
		if ?i {
			match i { 0 => idx(0), 1 => idx(1), _ => 1u32 }
		}
		else {
			idx(i)
		}
	}
}

fn @wrap_dim_3d(idx: fn (i32) -> u32) -> fn (i32) -> u32 {
	@|i: i32| -> u32 {
		if ?i {
			match i { 0 => idx(0), 1 => idx(1), 2 => idx(2), _ => 1u32 }
		}
		else {
			idx(i)
		}
	}
}

struct AccDevice {
	launch_1d: fn(i32, i32, fn (gpu_grid_context, Intrinsics) -> ()) -> (),
	synchronize: fn() -> (),
	alloc: fn(i32) -> Buffer,
	platform_device: i32,
	print_i32: fn(&[u8], i32) -> (),
	print_i32a: fn(&[u8], &[i32]) -> ()
}

struct BaseTest {
	run_test: fn (fn (AccDevice, &mut[1][i8], &mut[1]u32) -> bool) -> (),
	finish: fn () -> i32
}

fn createBaseTest(additional_mem: u32) -> BaseTest {
	let device = createAccDevice();

	let memory_size = round_up(additional_mem as i32 + sizeof[u32](), sizeof[u32]());
	let device_test_state_alloc = device.alloc(memory_size);
	let device_memory = bitcast[&mut[1][i8]](device_test_state_alloc.data);
	let device_failed_flag = bitcast[&mut[1]u32](&mut device_memory(memory_size - sizeof[u32]()));

	let zero = bitcast[&mut u32](runtime_alloc(0, sizeof[u32]() as i64));
	*zero = 0u32;
	runtime_copy(0, zero as &[i8], 0i64, device.platform_device, device_failed_flag as &mut[i8], 0i64, sizeof[u32]() as i64);
	runtime_release(0, zero as &[i8]);

	let mut cpu_result: bool = true;

	BaseTest {
		run_test: @|body| {
			cpu_result = cpu_result & body(device, device_memory, device_failed_flag);
		},

		finish: @|| {
			device.synchronize();

			let gpu_result = bitcast[&mut u32](runtime_alloc(0, sizeof[u32]() as i64));
			runtime_copy(device.platform_device, device_memory as &[i8], 0i64, 0, gpu_result as &mut[i8], 0i64, sizeof[u32]() as i64);

			print_string("gpu_result ");
			print_i32(*gpu_result as i32);
			print_char('\n');
			print_string("cpu_result ");
			print_i32((if cpu_result { 0 } else { 1 }));
			print_char('\n');

			let result = (if cpu_result { 0 } else { 1 }) + *gpu_result as i32;

			runtime_release(0, gpu_result as &[i8]);
			release(device_test_state_alloc);

			result
		}
	}
}


struct QueueTest {
	run_test: fn (i32, fn (AccDevice, ProducerConsumerQueue, &mut[1][i8], &mut[1]u32) -> bool) -> (),
	finish: fn () -> i32
}

fn createQueueTest(additional_mem: u32) -> QueueTest {
	let test = createBaseTest(additional_mem);

	// cuda_device is a static in cuda_mapping
	// device is a struct from createAccDevice()

	QueueTest {
		run_test: @|queue_size, body| {
			// let queue_buffer = alloc_cuda(device, queue_size * sizeof[i32]());
			// let queue_storage = bitcast[&mut[1][u32]](queue_buffer.data);

			with device, device_memory, device_failed_flag in test.run_test() {
				let queue = createProducerConsumerQueue(device, /*queue_storage,*/ queue_size);

				queue.reset();

				let mut cpu_result: bool = true;

				// TODO: properly refactor benchmark
				//with benchmark_cuda(cuda_device, 32) {
					if !body(device, queue, device_memory, device_failed_flag) {
						cpu_result = false;
					}
				//}

				queue.validate(device_failed_flag);
				queue.release();

				cpu_result
			}
		},

		finish: @|| {
			test.finish()
		}
	}
}
