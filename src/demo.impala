

fn @xorshift32(state: u32) -> u32 {
	let mut x = state;
	x ^= x << 13;
	x ^= x >> 17;
	x ^= x << 5;
	x
}


// based on Ken Perlin, Noise hardware. In Real-Time Shading SIGGRAPH Course Notes (2001), Olano M., (Ed.).
// https://www.csee.umbc.edu/~olano/s2002c36/ch02.pdf

type float3 = [f32 * 3];

fn @float3_add(a: float3, b: float3) -> float3 {
	[a(0) + b(0), a(1) + b(1), a(2) + b(2)]
}

fn @float3_sub(a: float3, b: float3) -> float3 {
	[a(0) - b(0), a(1) - b(1), a(2) - b(2)]
}

fn @float3_scale(a: float3, f: f32) -> float3 {
	[a(0) * f, a(1) * f, a(2) * f]
}

fn @float3_dot(a: float3, b: float3) -> f32 {
	a(0) * b(0) + a(1) * b(1) + a(2) * b(2)
}

fn @randf(x: u32, _intrinsics: Intrinsics) -> f32 {
	bitcast[f32]((127:u32 << 23:u32) | (xorshift32(x) >> 9:u32)) * 2.0 - 3.0
}

fn @noiseGradient(p: float3, intrinsics: Intrinsics) -> float3 {
	let seed1 = xorshift32(bitcast[u32](p(0)) ^ (bitcast[u32](p(2)) << 16));
	let seed2 = xorshift32(bitcast[u32](p(1)) ^ (bitcast[u32](p(2)) << 16));
	let u = randf(seed1, intrinsics);
	let theta = randf(seed2, intrinsics) * 3.14159265358979;

	let s = intrinsics.sqrtf(1.0 - u * u);

	[s * intrinsics.cosf(theta), s * intrinsics.sinf(theta), u]
}

fn @skew(p: float3) -> float3 {
	let s = (p(0) + p(1) + p(2)) / 3.0;
	[p(0) + s, p(1) + s, p(2) + s]
}

fn @unskew(p: float3) -> float3 {
	let s = (p(0) + p(1) + p(2)) / 6.0;
	[p(0) - s, p(1) - s, p(2) - s]
}

type simplex_t = [float3 * 4];

fn @simplex(p: float3, intrinsics: Intrinsics) -> simplex_t {
	let skewed_base = skew(p);
	let v_0 = unskew([intrinsics.floorf(skewed_base(0)), intrinsics.floorf(skewed_base(1)), intrinsics.floorf(skewed_base(2))]);

	let v = float3_sub(p, v_0);

	let b1 = v(0) < v(1);
	let b2 = v(1) < v(2);
	let b3 = v(2) < v(0);

	let e_1: [f32 * 3] = [ if !b1 &  b3 { 1 } else { 0 }, if !b2 &  b1 { 1 } else { 0 }, if !b3 &  b2 { 1 } else { 0 } ];
	let e_2: [f32 * 3] = [ if  b1 ^  b3 { 0 } else { 1 }, if  b2 ^  b1 { 0 } else { 1 }, if  b3 ^  b2 { 0 } else { 1 } ];
	let e_3: [f32 * 3] = [ if  b1 & !b3 { 1 } else { 0 }, if  b2 & !b1 { 1 } else { 0 }, if  b3 & !b2 { 1 } else { 0 } ];

	[ v_0, float3_add(v_0, unskew(e_1)), float3_add(v_0, unskew(float3_add(e_1, e_2))), float3_add(v_0, unskew(float3_add(e_1, float3_add(e_2, e_3)))) ]
}

fn @simplexContribution(d: float3, gradient: float3) -> f32 {
	let t = 0.5 - float3_dot(d, d);
	let t2 = t * t;
	let t4 = t2 * t2;

	if t > 0.0 { 8.0 * t4 * float3_dot(gradient, d) } else { 0.0 }
}

fn @simplexNoise(p: float3, intrinsics: Intrinsics) -> f32 {
	let s = simplex(p, intrinsics);

	simplexContribution(float3_sub(p, s(0)), noiseGradient(s(0), intrinsics)) +
	simplexContribution(float3_sub(p, s(1)), noiseGradient(s(1), intrinsics)) +
	simplexContribution(float3_sub(p, s(2)), noiseGradient(s(2), intrinsics)) +
	simplexContribution(float3_sub(p, s(3)), noiseGradient(s(3), intrinsics))
}

fn @simplexNoiseFractal(p: float3, N: i32, intrinsics: Intrinsics) -> f32
{
	let mut r: f32 = 0.0;

	for i in range(0, N) {
		r += (1.0 / (1 << i) as f32) * simplexNoise(float3_scale(p, (1 << i) as f32), intrinsics);
	}

	1.0 / (2.0 - 1.0 / (1 << (N - 1)) as f32) * r
}


type stage_factory = fn (AccDevice, Intrinsics) -> Stage;

fn demoStage1() -> Stage {
	Stage {
		produce = |_sink| {
			// let rand_state = xorshift32(i);
			// let elements = (rand_state % 8) as i32;
			// // (simplexNoiseFractal([randf(i, intrinsics), randf(i * 2, intrinsics), randf(i * 3, intrinsics)], octaves, intrinsics) * 8.0f32) as u32
			// for i in range(0, elements) {
			// 	sink(i);
			// }
		}
	}
}


fn demoStage2() -> Stage {
	Stage {
		produce = |_sink| {

		}
	}
}

