

fn main() -> i32 {
	let device = createAccDevice();

	let group_size = 256;
	let num_groups = 42;

	let test = createBaseTest(device, 0u32);

	// verify that only all lanes trigger wave barrier_all
	with device_memory, device_failed_flag in test.run_test() {
		with grid, intrinsics in device.launch_1d(num_groups, group_size) {
			with wave in grid.waves() {
				with thread in wave.threads() {
					for i in range(0, wave.num_threads() as i32) {

						if wave.barrier_all(thread.idx(0) == i as u32) != false {
							thread.atomic_or_global_u32(device_failed_flag, 1u << 0u);
						}
					}

					if wave.barrier_all(true) != true {
						thread.atomic_or_global_u32(device_failed_flag, 1u << 1u);
					}
				}
			}
		}

		true
	}

	// verify that any lane can trigger wave barrier_any
	with device_memory, device_failed_flag in test.run_test() {
		with grid, intrinsics in device.launch_1d(num_groups, group_size) {
			with wave in grid.waves() {
				with thread in wave.threads() {
					for i in range(0, wave.num_threads() as i32) {

						if wave.barrier_any(thread.idx(0) == i as u32) != true {
							thread.atomic_or_global_u32(device_failed_flag, 1u << 2u);
						}
					}

					if wave.barrier_any(false) != false {
						thread.atomic_or_global_u32(device_failed_flag, 1u << 3u);
					}
				}
			}
		}

		true
	}

	// verify that every vote counts in wave barrier_vote
	with device_memory, device_failed_flag in test.run_test() {
		with grid, intrinsics in device.launch_1d(num_groups, group_size) {
			with wave in grid.waves() {
				with thread in wave.threads() {
					// FIXME: nvcc / nvrtc generates incorrect code on Linux when range is used
					for i in unroll(0, wave.num_threads() as i32) {

						let expected = (1u64 << i as u64);

						if wave.barrier_vote(thread.idx(0) == i as u32) != expected {
							thread.atomic_or_global_u32(device_failed_flag, 1u << 4u);
						}
					}

					if wave.barrier_vote(true) != wave.membermask() {
						thread.atomic_or_global_u32(device_failed_flag, 1u << 5u);
					}
				}
			}
		}

		true
	}

	// verify that every lane counts in wave barrier_count
	with device_memory, device_failed_flag in test.run_test() {
		with grid, intrinsics in device.launch_1d(num_groups, group_size) {
			with wave in grid.waves() {
				with thread in wave.threads() {
					for i in range(0, wave.num_threads() as i32) {

						if wave.barrier_count(thread.idx(0) == i as u32) != 1 {
							thread.atomic_or_global_u32(device_failed_flag, 1u << 6u);
						}
					}

					if wave.barrier_count(true) as u32 != wave.num_threads() {
						thread.atomic_or_global_u32(device_failed_flag, 1u << 7u);
					}
				}
			}
		}

		true
	}

	// verify that only all threads trigger group barrier_all
	with device_memory, device_failed_flag in test.run_test() {
		with grid, intrinsics in device.launch_1d(num_groups, group_size) {
			with group in grid.groups() {
				with thread in group.threads() {
					for i in range(0, group.num_threads(0) as i32) {

						if group.barrier_all(thread.idx(0) == i as u32) != false {
							thread.atomic_or_global_u32(device_failed_flag, 1u << 8u);
						}
					}

					if group.barrier_all(true) != true {
						thread.atomic_or_global_u32(device_failed_flag, 1u << 9u);
					}
				}
			}
		}

		true
	}

	// verify that any threads can trigger group barrier_any
	with device_memory, device_failed_flag in test.run_test() {
		with grid, intrinsics in device.launch_1d(num_groups, group_size) {
			with group in grid.groups() {
				with thread in group.threads() {
					for i in range(0, group.num_threads(0) as i32) {

						if group.barrier_any(thread.idx(0) == i as u32) != true {
							thread.atomic_or_global_u32(device_failed_flag, 1u << 10u);
						}
					}

					if group.barrier_any(false) != false {
						thread.atomic_or_global_u32(device_failed_flag, 1u << 11u);
					}
				}
			}
		}

		true
	}

	// verify that every thread counts in group barrier_count
	with device_memory, device_failed_flag in test.run_test() {
		with grid, intrinsics in device.launch_1d(num_groups, group_size) {
			with group in grid.groups() {
				with thread in group.threads() {
					for i in range(0, group.num_threads(0) as i32) {

						if group.barrier_count(thread.idx(0) == i as u32) != 1 {
							thread.atomic_or_global_u32(device_failed_flag, 1u << 12u);
						}
					}

					if group.barrier_count(true) as u32 != group.num_threads(0) {
						thread.atomic_or_global_u32(device_failed_flag, 1u << 13u);
					}
				}
			}
		}

		true
	}

	test.finish()
}
