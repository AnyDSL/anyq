
type MoodycamelCQHandle = i64;
type MoodycamelValue = i64;

#[import(cc = "C", name = "moodycamel_cq_create")]       fn moodycamel_cq_create(_: &mut MoodycamelCQHandle) -> i32;
#[import(cc = "C", name = "moodycamel_cq_destroy")]      fn moodycamel_cq_destroy(_: MoodycamelCQHandle) -> i32;
#[import(cc = "C", name = "moodycamel_cq_enqueue")]      fn moodycamel_cq_enqueue(_: MoodycamelCQHandle, _: MoodycamelValue) -> i32;
#[import(cc = "C", name = "moodycamel_cq_try_dequeue")]  fn moodycamel_cq_try_dequeue(_: MoodycamelCQHandle, _:&mut MoodycamelValue) -> i32;
#[import(cc = "C", name = "moodycamel_cq_size_approx")]  fn moodycamel_cq_size_approx(_: MoodycamelCQHandle) -> i64;


fn @createMoodyCamelQueue[T](device: AccDevice, pool_size: i32) -> ProducerConsumerQueue[T] {

	let buffer_size = pool_size as i64 * sizeof[T]();

	let buffer = device.alloc(buffer_size);
	let memory = bitcast[&mut addrspace(1) [T]](buffer.data);

	let mut alloc_next:u32 = 0;
	let alloc_ptr = bitcast[&mut addrspace(1) u32](&mut alloc_next);

	let nil:u32 = -1;
	let alloc_slot = @|thread:gpu_thread_context| -> u32 {
		let new_slot = thread.atomic_add_global_u32(alloc_ptr, 1, memory_order::relaxed);

		if new_slot < pool_size as u32 {
			new_slot
		}
		else {
			thread.atomic_sub_global_u32(alloc_ptr, 1, memory_order::relaxed);
			nil
		}
	};

	let mut queue:MoodycamelCQHandle;

	let success = moodycamel_cq_create(&mut queue);
	assert(success > 0, "moodycamel_cq_create() failed");

	ProducerConsumerQueue[T] {
		push = @|source:fn(u32)->T| @|thread:gpu_thread_context| -> i32 {
			let slot = alloc_slot(thread);
			if (slot != nil) {
				memory(slot) = source(slot);
				let success = moodycamel_cq_enqueue(queue, slot as i64);
				if success > 0 { 1 } else { 0 }
			} else {
				0
			}
		},

		pop = @|sink:fn(T, u32)->()| @|thread:gpu_thread_context| -> i32 {
			let mut slot:i64 = thread.idx(0) as i64;
			let success = moodycamel_cq_try_dequeue(queue, &mut slot);
			if success > 0 {
				let value:T = memory(slot);
				sink(value, slot as u32);
				1
			} else {
				0
			}
		},

		size = @|_thread| {
			moodycamel_cq_size_approx(queue) as i32
		},

		reset = @|_grid| {
			let mut success:i32;
			//success = moodycamel_cq_destroy(queue);
			//assert(success > 0, "moodycamel_cq_destroy() failed");
			success = moodycamel_cq_create(&mut queue);
			assert(success > 0, "moodycamel_cq_create() failed");
		},

		validate = @|_corrupted: &mut addrspace(1) u32, grid| {
			for _thread in grid.threads() {
				// TODO
			}
		},

		release = @|| {
			let success = moodycamel_cq_destroy(queue);
			assert(success > 0, "moodycamel_cq_destroy() failed");
		}
	}
}
