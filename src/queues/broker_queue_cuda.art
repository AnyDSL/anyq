// implementation of queue algorithm described in
// Bernhard Kerbl, Michael Kenzel, Joerg H. Mueller, Dieter Schmalstieg, Markus Steinberger, 2018, The Broker Queue: A Fast, Linearizable FIFO Queue for Fine-Granular Work Distribution on the GPU
// ICS '18: Proceedings of the 2018 International Conference on Supercomputing, pages 76â€“85
// https://doi.org/10.1145/3205289.3205291


#[import(cc = "C", name = "bq_init_1000")] fn bq_init_1000() -> ();
#[import(cc = "C", name = "bq_init_10000")] fn bq_init_10000() -> ();
#[import(cc = "C", name = "bq_init_100000")] fn bq_init_100000() -> ();
#[import(cc = "C", name = "bq_init_1000000")] fn bq_init_1000000() -> ();
#[import(cc = "C", name = "bq_init_fail")] fn bq_init_fail() -> ();

#[import(cc = "C", name = "bq_push_1000")] fn bq_push_1000[T](T) -> i32;
#[import(cc = "C", name = "bq_push_10000")] fn bq_push_10000[T](T) -> i32;
#[import(cc = "C", name = "bq_push_100000")] fn bq_push_100000[T](T) -> i32;
#[import(cc = "C", name = "bq_push_1000000")] fn bq_push_1000000[T](T) -> i32;
#[import(cc = "C", name = "bq_push_fail")] fn bq_push_fail[T](T) -> i32;

#[import(cc = "C", name = "bq_pop_1000")] fn bq_pop_1000[T](&mut T) -> i32;
#[import(cc = "C", name = "bq_pop_10000")] fn bq_pop_10000[T](&mut T) -> i32;
#[import(cc = "C", name = "bq_pop_100000")] fn bq_pop_100000[T](&mut T) -> i32;
#[import(cc = "C", name = "bq_pop_1000000")] fn bq_pop_1000000[T](&mut T) -> i32;
#[import(cc = "C", name = "bq_pop_fail")] fn bq_pop_fail[T](&mut T) -> i32;


fn @createBrokerWorkDistributorQueueCUDA[T](_device: AccDevice, queue_size: i32) -> ProducerConsumerQueue[T] {
	let bq_init = match (queue_size) {
		1000 => bq_init_1000,
		10000 => bq_init_10000,
		100000 => bq_init_100000,
		1000000 => bq_init_1000000,
		_ => bq_init_fail
	};

	let bq_push = match (queue_size) {
		1000 => bq_push_1000[T],
		10000 => bq_push_10000[T],
		100000 => bq_push_100000[T],
		1000000 => bq_push_1000000[T],
		_ => bq_push_fail[T]
	};

	let bq_pop = match (queue_size) {
		1000 => bq_pop_1000[T],
		10000 => bq_pop_10000[T],
		100000 => bq_pop_100000[T],
		1000000 => bq_pop_1000000[T],
		_ => bq_pop_fail[T]
	};

	ProducerConsumerQueue[T] {
		push = @|source:fn(u32)->T| @|_thread:gpu_thread_context| -> i32 {
			bq_push(source(0))
		},

		pop = @|sink:fn(T, u32)->()| @|_thread:gpu_thread_context| -> i32 {
			let mut el:T;

			let res = bq_pop(&mut el);
			
			if res > 0 {
				sink(el, 0);
			}

			res
		},

		size = @|_thread| {
			0  // TODO
		},

		reset = @|grid| {
			for _thread in grid.threads() {
				bq_init();
			}
		},

		validate = @|_corrupted: &mut addrspace(1) u32, _grid| {
		},

		release = @|| {
		}
	}
}
