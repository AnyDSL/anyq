
#[import(cc = "device")] fn magic_p_id(u32) -> u32;  // HACK to force evaluation of expression on the host


fn producer_consumer_queue_concurrent_push_pop_benchmark(block_size: i32, attempts_per_thread: i32, p_enq: f32, p_deq: f32, workload_size: i32, queue_size: i32) {
	let device = createAccDevice();

	let queue = createConcurrentProducerConsumerIndexQueue(device, queue_size);


	for grid in device.launch_1d(div_up(queue_size, block_size), block_size) {
		queue.reset(grid);
	}

	let rand_mask = @|p: f32| (((-1 as u32) as f64 * p as f64) as u32);
	let c_enq = magic_p_id(rand_mask(p_enq));
	let c_deq = magic_p_id(rand_mask(p_deq));

	@|num_threads: i32| {
		for grid in device.launch_1d(div_up(num_threads, block_size), block_size) {
			for wave in grid.waves() {
				for thread in wave.threads() {
					let thread_id = wave.idx() * wave.num_threads() + thread.idx(0);

					let mut rand_state = rng::xorseed32(thread_id);

					let sample = @|c: u32| -> bool {
							rng::xorshift32(rand_state) < c
					};

					let simulate_workload = @|| {
						for _ in range(0, workload_size) {
							rand_state = rng::xorshift32(rand_state);
						}
					};

					for _ in range(0, attempts_per_thread) {
						if sample(c_enq) {
							for _ in queue.push(thread) {
								simulate_workload();
								rand_state
							};
						}

						wave.barrier();

						if sample(c_deq) {
							for _, _ in queue.pop(thread) {
								simulate_workload();
							};
						}

						wave.barrier();
					}
				}
			}
		}
	}
}
