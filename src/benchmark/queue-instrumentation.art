
fn wrap_queue_instrumentation[T](queue: ProducerConsumerQueue[T], stats: &mut QueueBenchmarkStatistics) -> ProducerConsumerQueue[T] {
	let wrapped_queue = ProducerConsumerQueue[T] {
		push = @|source:fn()->T| @|thread:gpu_thread_context| -> i32 {

			let t_begin = thread.timestamp32();

			let num_pushed = for queue.push(thread) {
				source()
			};

			let t_end = thread.timestamp32();

			let dt = t_end - t_begin;

			if num_pushed > 0 {
				record_queue_operation(stats.enqueue_stats_succ, dt);
			}
			else {
				record_queue_operation(stats.enqueue_stats_fail, dt);
			}

			num_pushed
		},

		pop = @|sink:fn(T)->()| @|thread:gpu_thread_context| -> i32 {

			let t_begin = thread.timestamp32();

			let num_poppped = for el in queue.pop(thread) {
				sink(el);
			};

			let t_end = thread.timestamp32();

			let dt = t_end - t_begin;

			if num_poppped > 0 {
				record_queue_operation(stats.dequeue_stats_succ, dt);
			}
			else {
				record_queue_operation(stats.dequeue_stats_fail, dt);
			}

			num_poppped
		},

		size = queue.size,
		reset = queue.reset,
		validate = queue.validate,
		release = queue.release
	};

	wrapped_queue
}
