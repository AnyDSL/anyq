
fn @upsweep_exponential(body: fn(i32) -> ()) {
	fn @(?min & ?max & ?exp) loop(min: i32, max: i32, exp: i32) -> () {
		if min <= max {
			@body(min);
			loop(min * exp, max, exp);
		}
	}
	loop
}

struct QueueOperationStatistics {
	num_operations: i64,
	t_total: i64,
	t_min: i32,
	t_max: i32,
}

struct QueueBenchmarkStatistics {
	enqueue_stats_succ: QueueOperationStatistics,
	enqueue_stats_fail: QueueOperationStatistics,
	dequeue_stats_succ: QueueOperationStatistics,
	dequeue_stats_fail: QueueOperationStatistics
}

fn init_queue_operation_stats() = QueueOperationStatistics {
	num_operations = 0,
	t_total = 0,
	t_min = ((1 as u32 << 31) - 1) as i32,
	t_max = 0
};

fn @record_queue_operation(stats: &mut QueueOperationStatistics, t: i32) {
	++stats.num_operations;
	stats.t_total += t as i64;
	stats.t_min = min(stats.t_min, t);
	stats.t_max = max(stats.t_max, t);
}

fn init_benchmark_stats() = QueueBenchmarkStatistics {
	enqueue_stats_succ = init_queue_operation_stats(),
	enqueue_stats_fail = init_queue_operation_stats(),
	dequeue_stats_succ = init_queue_operation_stats(),
	dequeue_stats_fail = init_queue_operation_stats(),
};

fn accumulate_queue_operation_stats(dest: &mut addrspace(1) QueueOperationStatistics, stats: QueueOperationStatistics, thread: gpu_thread_context) {
	thread.atomic_add_global_i64(dest.num_operations, stats.num_operations, memory_order::relaxed);
	thread.atomic_add_global_i64(dest.t_total, stats.t_total, memory_order::relaxed);
	thread.atomic_min_global_i32(dest.t_min, stats.t_min, memory_order::relaxed);
	thread.atomic_max_global_i32(dest.t_max, stats.t_max, memory_order::relaxed);
}

fn accumulate_benchmark_stats(dest: &mut addrspace(1) QueueBenchmarkStatistics, stats: QueueBenchmarkStatistics, thread: gpu_thread_context) {
	accumulate_queue_operation_stats(&mut dest.enqueue_stats_succ, stats.enqueue_stats_succ, thread);
	accumulate_queue_operation_stats(&mut dest.enqueue_stats_fail, stats.enqueue_stats_fail, thread);
	accumulate_queue_operation_stats(&mut dest.dequeue_stats_succ, stats.dequeue_stats_succ, thread);
	accumulate_queue_operation_stats(&mut dest.dequeue_stats_fail, stats.dequeue_stats_fail, thread);
}


struct QueueBenchmark {
	reset: fn() -> (),
	run: fn(i32, i32) -> (),
	read_stats: fn() -> QueueBenchmarkStatistics
}


fn @run_queue_benchmark(device: i32, num_threads_min: i32, num_threads_max: i32, benchmark: QueueBenchmark) -> i32 {
	let instrumentation = create_instrumentation(device);

	print_string("platform;device_name\n");
	instrumentation.print_device_info();
	print_char('\n');
	print_char('\n');

	print_string("num_threads;t/ms;num_enqueues;t_enqueues;t_enqueue_min;t_enqueue_max;num_enqueues_failed;t_enqueues_failed;t_enqueue_failed_min;t_enqueue_failed_max;num_dequeues;t_dequeues;t_dequeue_min;t_dequeue_max;num_dequeues_failed;t_dequeues_failed;t_dequeue_failed_min;t_dequeue_failed_max\n");

	let N = 10;

	for num_threads in upsweep_exponential(num_threads_min, num_threads_max, 2) {
		for i in range(0, N) {
			print_i32(num_threads); print_char(';');

			benchmark.reset();

			for instrumentation.time() {
				benchmark.run(num_threads, i);
			}

			let stats = benchmark.read_stats();

			let print_stat = @|stats:QueueOperationStatistics| {
				print_char(';');
				print_i64(stats.num_operations); print_char(';');
				print_i64(stats.t_total); print_char(';');
				print_i32(stats.t_min); print_char(';');
				print_i32(stats.t_max);
			};

			print_stat(stats.enqueue_stats_succ);
			print_stat(stats.enqueue_stats_fail);
			print_stat(stats.dequeue_stats_succ);
			print_stat(stats.dequeue_stats_fail);
			print_char('\n');
			print_flush();
		}
	}

	0
}
