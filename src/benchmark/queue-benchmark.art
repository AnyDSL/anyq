
fn @upsweep_exponential(body: fn(i32) -> ()) {
	fn @(?min & ?max & ?exp) loop(min: i32, max: i32, exp: i32) -> () {
		if min <= max {
			@body(min);
			loop(min * exp, max, exp);
		}
	}
	loop
}


struct QueueBenchmarkStatistics {
	num_enqueues: i32,
	num_enqueue_attempts: i32,
	num_dequeues: i32,
	num_dequeue_attempts: i32,
	t_enqueue: i64,
	t_enqueue_min: i32,
	t_enqueue_max: i32,
	t_dequeue: i64,
	t_dequeue_min: i32,
	t_dequeue_max: i32
}

fn init_benchmark_stats() = QueueBenchmarkStatistics {
	num_enqueues = 0,
	num_enqueue_attempts = 0,
	num_dequeues = 0,
	num_dequeue_attempts = 0,
	t_enqueue = 0,
	t_enqueue_min = ((1 as u32 << 31) - 1) as i32,
	t_enqueue_max = 0,
	t_dequeue = 0,
	t_dequeue_min = ((1 as u32 << 31) - 1) as i32,
	t_dequeue_max = 0
};

fn accumulate_benchmark_stats(dest: &mut addrspace(1) QueueBenchmarkStatistics, stats: QueueBenchmarkStatistics, thread: gpu_thread_context) {
	thread.atomic_add_global_i32(dest.num_enqueues, stats.num_enqueues, memory_order::relaxed);
	thread.atomic_add_global_i32(dest.num_enqueue_attempts, stats.num_enqueue_attempts, memory_order::relaxed);
	thread.atomic_add_global_i32(dest.num_dequeues, stats.num_dequeues, memory_order::relaxed);
	thread.atomic_add_global_i32(dest.num_dequeue_attempts, stats.num_dequeue_attempts, memory_order::relaxed);
	thread.atomic_add_global_i64(dest.t_enqueue, stats.t_enqueue, memory_order::relaxed);
	thread.atomic_min_global_i32(dest.t_enqueue_min, stats.t_enqueue_min, memory_order::relaxed);
	thread.atomic_max_global_i32(dest.t_enqueue_max, stats.t_enqueue_max, memory_order::relaxed);
	thread.atomic_add_global_i64(dest.t_dequeue, stats.t_dequeue, memory_order::relaxed);
	thread.atomic_min_global_i32(dest.t_dequeue_min, stats.t_dequeue_min, memory_order::relaxed);
	thread.atomic_max_global_i32(dest.t_dequeue_max, stats.t_dequeue_max, memory_order::relaxed);
}


struct QueueBenchmark {
	reset: fn() -> (),
	run: fn(i32) -> (),
	read_stats: fn() -> QueueBenchmarkStatistics
}


fn @run_queue_benchmark(device: i32, num_threads_min: i32, num_threads_max: i32, benchmark: QueueBenchmark) -> i32 {
	let instrumentation = create_instrumentation(device);

	print_string("platform;device_name\n");
	instrumentation.print_device_info();
	print_char('\n');
	print_char('\n');

	print_string("num_threads;t/ms;num_enqueues;num_enqueue_attempts;num_dequeues;num_dequeue_attempts;t_enqueue;t_enqueue_min;t_enqueue_max;t_dequeue;t_dequeue_min;t_dequeue_max\n");

	let N = 10;

	for num_threads in upsweep_exponential(num_threads_min, num_threads_max, 2) {
		for _ in range(0, N) {
			print_i32(num_threads); print_char(';');

			benchmark.reset();

			for instrumentation.time() {
				benchmark.run(num_threads);
			}

			let stats = benchmark.read_stats();

			print_char(';');
			print_i32(stats.num_enqueues); print_char(';');
			print_i32(stats.num_enqueue_attempts); print_char(';');
			print_i32(stats.num_dequeues); print_char(';');
			print_i32(stats.num_dequeue_attempts); print_char(';');
			print_i64(stats.t_enqueue); print_char(';');
			print_i32(stats.t_enqueue_min); print_char(';');
			print_i32(stats.t_enqueue_max); print_char(';');
			print_i64(stats.t_dequeue); print_char(';');
			print_i32(stats.t_dequeue_min); print_char(';');
			print_i32(stats.t_dequeue_max); print_char('\n');
			print_flush();
		}
	}

	0
}
