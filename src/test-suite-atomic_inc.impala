
fn @setup_input(num_globals: i32, num_locals: i32) -> (fn(i32)->i32,fn(i32)->i32) {
	let global = @|g| { 0 };
	let local  = @|l| { l };
	(global, local)
}

fn @wrap_around_value(value: i32) -> u32 {
	(1 << (4 + value)) as u32
}

fn @test_body(grid: gpu_grid_context, intrinsics: Intrinsics, read: ReadFn, write: WriteFn, global: GlobalFn) -> () {

	with block in grid.groups() {
		with thread in block.threads() {

			let bidx = block.idx(0) as i32;
			let tidx = bidx * block.num_threads(0) as i32 + thread.idx(0) as i32;

			let mydata = read(tidx);

			let ptr = bitcast[&mut[1]u32](global(bidx));

			//if mydata & 1 == 0 {
				let newdata = thread.atomic_inc_global_u32(ptr, wrap_around_value(bidx) - 1u) as i32;

				write(bidx * block.num_threads(0) as i32 + newdata, -(1 << bidx));
			//}
		}
	}

}

fn @expected_result(global: fn(i32)->i32, local: fn(i32)->i32) -> (fn(i32)->i32, fn(i32)->i32) {

	let values = |l| {
		let bidx = (l >> 7) & 0x3;
		let tidx = l & 0x7f;
		let wrap = wrap_around_value(bidx) as i32;
		if tidx < wrap /* && tidx & 1 == 0 */ {
			-(1 << bidx)
		} else {
			l
		}
	};

	// atmost the wrap around bit shall be set
	let result = |g| global(g) & wrap_around_value(g) as i32;

	(result, values)
}
